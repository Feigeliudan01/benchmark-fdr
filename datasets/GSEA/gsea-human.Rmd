---
title: "Case Study: Gene Set Enrichment Analysis (Human Data Set)"
author: "Alejandro Reyes"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
   html_document:
        toc: true
        toc_float: true
        highlight: tango
        number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Summary

The objective of this document is to compare different methods for multiple testing correction in the context of Gene Set Enrichment Analysis (GSEA). In order to get a list of genes, we will use RNA-seq data consisting of cortex and cerebellum samples of a subset of the GTEx data. 

# Workspace Setup

```{r}
library(dplyr)
library(ggplot2)
library(scales)
library(DESeq2)
library(EnsDb.Hsapiens.v86)
library(biomaRt)
library(goseq)

## load helper functions
for (f in list.files("../R", "\\.(r|R)$", full.names = TRUE)) {
    source(f)
}

## project data/results folders
datdir <- "data"
resdir <- "results"
sbdir <- "../../results/GSEA"
dir.create(datdir, showWarnings = FALSE)
dir.create(resdir, showWarnings = FALSE)
dir.create(sbdir, showWarnings = FALSE)

## intermediary files we create below
count_file <- file.path(datdir, "human-counts.rds")
deseq_file <- file.path(datdir, "human-deseq.rds")
goset_file <- file.path(datdir, "human-gosets.rds")
result_file <- file.path(resdir, "human-results.rds")
bench_file <- file.path(sbdir, "human-benchmark.rds")
bench_file_uninf <- file.path(sbdir, "human-uninf-benchmark.rds")
```

# Data Preparation

The dataset consists of 10 samples (6 cerebellum and 4 cortex samples), all from male individuals. We download a *DESeqDataSet* if not present locally and modify the design to test for differences in gene expression between cerebellums and cortex.
	    
```{r, message=FALSE}
if (!file.exists(count_file)) {
    download.file("https://www.dropbox.com/s/itrs2a6cnmurnck/gsea-human-counts.rds?dl=1",
                  destfile = count_file)
}
dsdObject <- readRDS(count_file)
design( dsdObject ) <- ~ tissue
```

To keep running times short, we only perform differential tesing on protein coding genes, as specified in Ensembl release 86. 

```{r}
gnType <- genes(EnsDb.Hsapiens.v86, column = "gene_biotype")
protGenes <- gnType$gene_id[gnType$gene_biotype == "protein_coding"]
dsdObject <- dsdObject[rownames(dsdObject) %in% protGenes, ]
```

# Data Analysis

## Enrichment Analysis

Next, we run DESeq2 to retrieve a list of differentially expressed genes at a FDR of 10%. 

```{r deseq2, message=FALSE}
if (!file.exists(deseq_file)) {
    dsdObject <- DESeq(dsdObject)
    res <- results(dsdObject, independentFiltering = FALSE)
    saveRDS(res, file = deseq_file)
} else {
    res <- readRDS(deseq_file)
}

genes <- as.numeric(res$padj < 0.1)
names(genes) <- rownames(res)
```

Next we’ll use the biomaRt package to download and associate GO annotations for each gene. 

```{r goseq, message=FALSE}
if (!file.exists(goset_file)) {
    mart <- useMart("ensembl", "hsapiens_gene_ensembl")
    goSets <- getBM(c("ensembl_gene_id", "go_id"), mart = mart,
                    filters = "ensembl_gene_id", values = rownames(res))
    goSets <- goSets[!nchar( goSets$go_id ) == 0, ]
    goSets <- with(goSets, split(go_id, ensembl_gene_id))
    saveRDS(goSets, file = goset_file)
} else {
    goSets <- readRDS(goset_file)
}
```

Finally, we’ll perform a gene set enrichment analysis with goseq. goseq performs GSEA and adjusts for gene length biases. The bias is represented in the plot below, with gene length bin on the x-axis and proportion of genes detected to be differentially expressed on the y-axis.

```{r}
if (!file.exists(result_file)) {
    ## get median transcript length for bias adjustment
    txByGene <- transcriptsBy(EnsDb.Hsapiens.v86, "gene")
    geneLength <- sapply(width(txByGene), median)
    geneLength <- geneLength[names(genes)]
    genes[is.na(genes)] <- 0

    ## perform gsea
    pwf <- nullp(genes, bias.data = geneLength)
    goRes <- goseq(pwf, gene2cat = goSets)

    saveRDS(goRes, file = result_file)
} else {
    goRes <- readRDS(result_file)
}

## Add random (uninformative) covariate
set.seed(66778)
goRes$rand_covar <- rnorm(nrow(goRes))

```

## Covariate Diagnostics

Here, we can see that the covariant variable is actually informative.

### Gene Set Size

We will explore whether the size of the gene set can be used as a covariate for modern multiple-testing correction methods in the context of GSEA. In the plot below, the log10 of the p-values is plotted as a function of the size of the gene set. There is a pattern in which gene sets with a higher number of genes tend to have smaller p-values, which is indicative that gene set size is an informative covariate. 

```{r informativeCovariate, message=FALSE, fig.height=3.5, message=FALSE, fig.width=4.5}
rank_scatter(dat = goRes, pval = "over_represented_pvalue", 
              covariate = "numInCat", bins = 50, funx = log2, 
              funfill = log10_trans()) +
    ylim(0, 12) +
    ggtitle("Over-represented gene sets") +
    xlab(expression(log[10]~"(# of genes)")) +
    ylab(expression(-log[10]~"(p-value)") ) 
```

We can also explore if the covariate seems to be independent under the null. 

```{r assumptions, message=FALSE, fig.width=10, fig.height=3.2}
## filter numInCat below only used for plotting
## filter numDEInCat for cases where there are no DE genes in the category (these are actually not tested)
#dplyr::filter( goRes, over_represented_pvalue == 1, numDEInCat > 0)
dplyr::filter( goRes, numDEInCat > 0, numInCat > 10 ) %>%
    strat_hist( pval="over_represented_pvalue", covariate="numInCat", maxy=18)
```
 
### Random

We will explore whether the random covariate can be used as a covariate for modern multiple-testing correction methods in the context of GSEA. In the plot below, the log10 of the p-values is plotted as a function of the 
random covariate. This covariate looks independent of the p-values.

```{r informativeCovariate-rand, message=FALSE, fig.height=3.5, message=FALSE, fig.width=4.5}
rank_scatter(dat = goRes, pval = "over_represented_pvalue", 
              covariate = "rand_covar", bins = 50, 
              funfill = log10_trans()) +
    ylim(0, 12) +
    ggtitle("Over-represented gene sets") +
    ylab(expression(-log[10]~"(p-value)") ) 
```

We can also explore if the covariate seems to be independent under the null. 

```{r assumptions-rand, message=FALSE, fig.width=10, fig.height=3.2}
## filter numInCat below only used for plotting
## filter numDEInCat for cases where there are no DE genes in the category (these are actually not tested)
#dplyr::filter( goRes, over_represented_pvalue == 1, numDEInCat > 0)
dplyr::filter( goRes, numDEInCat > 0, numInCat > 10 ) %>%
    strat_hist( pval="over_represented_pvalue", covariate="rand_covar", maxy=10)
```
  
 
## Multiple-Testing Correction

We then execute the benchDesign and generate a *SummarizedBenchmark* object containing multiple-testing corrections using several methods. 
 
```{r setup-benckmark, message=FALSE}
## rename columns and prepare for benchmarking
res <- dplyr:::select(goRes, c("over_represented_pvalue", "numInCat", "rand_covar")) %>%
    dplyr:::rename(pval = over_represented_pvalue, ind_covariate = numInCat)
res$pval <- pmin(res$pval, 1)

## generate default BenchDesign
bd <- initializeBenchDesign()
```

We exclude `ashr`, `scott-theoretical` and `scott-empirical` from the analysis because
the necessary assumptions are not met in the current case study. Namely, effect sizes
and standard errors are not available for ASH, and the test statistics are not normally
distributed under the null and alternative, as required by Scott's FDR regression methods.

```{r run-benchmark}
if (!file.exists(bench_file)) {
  sGSEA <- buildBench(bd, res, ftCols = "ind_covariate")
  saveRDS(sGSEA, file = bench_file)
} else {
  sGSEA <- readRDS(bench_file)
}
```

We'll also compare the results to an uninformative (random) covariate.

```{r run-benchmark-rand}
if (!file.exists(bench_file_uninf)) {
  res$ind_covariate <- res$rand_covar
  sGSEA_rand <- buildBench(bd, res, ftCols = "ind_covariate")
  saveRDS(sGSEA_rand, file = bench_file_uninf)
} else {
  sGSEA_rand <- readRDS(bench_file_uninf)
}
```

## Benchmark Metrics

### Gene Set Size

```{r}
assayNames(sGSEA) <- "qvalue"
sGSEA <- addDefaultMetrics(sGSEA)
sGSEA <- estimatePerformanceMetrics(sGSEA, addColData=TRUE)
```

```{r plottingResults}
rejections_scatter(sGSEA, as_fraction=FALSE, supplementary=FALSE)
```
  
```{r}
plotFDRMethodsOverlap(sGSEA, alpha=0.1, supplementary=FALSE, order.by="freq", nsets=100)
```

```{r}
covariateLinePlot(sGSEA, alpha = 0.1, covname = "ind_covariate", trans = "log1p")
```

### Random

```{r}
assayNames(sGSEA_rand) <- "qvalue"
sGSEA_rand <- addDefaultMetrics(sGSEA_rand)
sGSEA_rand <- estimatePerformanceMetrics(sGSEA_rand, addColData=TRUE)
```

```{r plottingResults-rand}
rejections_scatter(sGSEA_rand, as_fraction=FALSE, supplementary=FALSE)
```
  
```{r}
plotFDRMethodsOverlap(sGSEA_rand, alpha=0.1, supplementary=FALSE, order.by="freq", nsets=100)
```

```{r}
covariateLinePlot(sGSEA_rand, alpha = 0.1, covname = "ind_covariate", trans = "log1p")
```

## Covariate comparison

Here we compare the method ranks for the two covariates at alpha = 0.10.

```{r}
plotMethodRanks(c(bench_file, bench_file_uninf), 
                colLabels = c("Set Size", "Random"), 
                alpha = 0.10, xlab = "Covariate", 
                excludeMethods = NULL)
``` 

# Session Info

```{r}
sessionInfo()
```
