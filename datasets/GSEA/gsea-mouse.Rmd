---
title: "Case Study: Gene Set Enrichment Analysis (Mouse Data Set)"
author: "Alejandro Reyes"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
   html_document:
        toc: true
        toc_float: true
        highlight: tango
        number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Summary

The objective of this vignette is to test different multiple testing methods in the context of Gene Set Enrichment Analysis (GSEA). To do this, we will use mouse data from the paper by [Cabezas-Wallscheid et al. (Cell stem Cell, 2014)](https://www.sciencedirect.com/science/article/pii/S1934590914003014?via%3Dihub). The dataset consists of RNA-seq data from mouse hematopoietic stem cells and 4 multipotent progenitor lineages. We will test for difference in gene expression between two different cell fractions and perform GSEA in the resulting list of genes. 

# Workspace Setup

```{r}
library(dplyr)
library(ggplot2)
library(scales)
library(DESeq2)
library(EnsDb.Mmusculus.v75)
library(biomaRt)
library(goseq)

## load helper functions
for (f in list.files("../R", "\\.(r|R)$", full.names = TRUE)) {
    source(f)
}

## project data/results folders
datdir <- "data"
resdir <- "results"
sbdir <- "../../results/GSEA"
dir.create(datdir, showWarnings = FALSE)
dir.create(resdir, showWarnings = FALSE)
dir.create(sbdir, showWarnings = FALSE)

## intermediary files we create below
count_file <- file.path(datdir, "mouse-counts.rds")
deseq_file <- file.path(datdir, "mouse-deseq.rds")
goset_file <- file.path(datdir, "mouse-gosets.rds")
result_file <- file.path(resdir, "mouse-results.rds")
bench_file <- file.path(sbdir, "mouse-benchmark.rds")
bench_file_uninf <- file.path(sbdir, "mouse-uninf-benchmark.rds")
```

# Data Preparation

The data has been preprocessed and saved as a DESeqDataset object. The following lines of code download this *DESeqDataSet* if it is not present locally.

```{r, message=FALSE}
if (!file.exists(count_file)) {
    download.file("https://www.dropbox.com/s/jq6giqeclxcdypq/gsea-mouse-counts.rds?dl=1",
                  destfile = count_file)
}
dseHSCMPP <- readRDS(count_file)
```

**Why no filtering on gene_biotype == "protein_coding" for this data? AR: I think I did this in the other vignette to keep running times short. This shouldn't change the result since anyway protein coding genes are those with GO categories and genes without GO assignments are ignored.**

# Data Analysis

## Enrichment Analysis

In order to get a list of genes to test for GSEA, we will test each gene for differential gene expression between hematopoietic stem cells and multipotent progenitors (fraction 1). To do this, we will run DESeq2 to retrieve genes differentially expressed at a FDR of 10%.

```{r deseq2, message=FALSE}
if (!file.exists(deseq_file)) {
    dseHSCMPP <- DESeq(dseHSCMPP)
    res <- results(dseHSCMPP, contrast = c("conditions", "HSC", "MPP1"),
                   independentFiltering = FALSE)
    saveRDS(res, file = deseq_file)
} else {
    res <- readRDS(deseq_file)
}

genes <- as.numeric(res$padj < 0.1)
names(genes) <- rownames(res)
sum(genes, na.rm=TRUE)
```

We next use biomaRt to get the relations between GO categories and genes.

```{r goseq, message=FALSE}
if (!file.exists(goset_file)) {
    mart <- useMart("ensembl", "mmusculus_gene_ensembl")
    goSets <- getBM(c("ensembl_gene_id", "go_id"), mart = mart,
                    filters = "ensembl_gene_id", values = rownames(res))
    goSets <- goSets[!nchar(goSets$go_id) == 0, ]
    goSets <- with(goSets, split(go_id, ensembl_gene_id))
    saveRDS(goSets, file = goset_file)
} else {
   goSets <- readRDS(goset_file)
}
```

Now we are ready to perform gene set enrichment analysis using `goseq`.

```{r}
if (!file.exists(result_file)) {
    ## getting median transcript length
    txByGene <- transcriptsBy(EnsDb.Mmusculus.v75, "gene")
    geneLength <- sapply(width(txByGene), median)
    geneLength <- geneLength[names(genes)]
    genes[is.na(genes)] <- 0
    
    ## perform gsea
    pwf <- nullp(genes, bias.data = geneLength)
    goRes <- goseq(pwf, gene2cat = goSets)

    saveRDS(goRes, file = result_file)
} else {
    goRes <- readRDS(result_file)
}

## Add random (uninformative) covariate
set.seed(7476)
goRes$rand_covar <- rnorm(nrow(goRes))

```

We filter out really small gene sets and those gene sets which have no DE genes
in them (many of these are set to 1).

```{r}
goRes <- goRes %>%
  dplyr::filter(numDEInCat > 0, numInCat > 10 )
```

## Covariate Diagnostics

Here, we can see that the size of the gene set is actually informative.

### Gene Set Size

In the following plot, we explore the relationship between the p-value and the gene set size. We can see that this covariate is actually informative. 

```{r informativeCovariate, message=FALSE, fig.height=3.5, message=FALSE, fig.width=4.5}
rank_scatter(dat = goRes, pval = "over_represented_pvalue", 
             covariate = "numInCat", bins = 50, funx = log2, 
             funfill = log10_trans()) +
    ylim(0, 12) +
    ggtitle("Over-represented gene sets") +
    xlab(expression(log[10]~"(# of genes)")) +
    ylab(expression(-log[10]~"(p-value)")) 
```

And at the same time, it seems to be fair to assume that it is independent under the null hypothesis.

```{r assumptions, message=FALSE, fig.width=10, fig.height=3.2}
strat_hist(goRes, pval = "over_represented_pvalue", covariate = "numInCat", maxy=7)
```

### Random

We will explore whether the random covariate can be used as a covariate for modern multiple-testing correction methods in the context of GSEA. In the plot below, the log10 of the p-values is plotted as a function of the 
random covariate. This covariate looks independent of the p-values.

```{r informativeCovariate-rand, message=FALSE, fig.height=3.5, message=FALSE, fig.width=4.5}
rank_scatter(dat = goRes, pval = "over_represented_pvalue", 
              covariate = "rand_covar", bins = 50, 
              funfill = log10_trans()) +
    ylim(0, 12) +
    ggtitle("Over-represented gene sets") +
    ylab(expression(-log[10]~"(p-value)") ) 
```

We can also explore if the covariate seems to be independent under the null. 

```{r assumptions-rand, message=FALSE, fig.width=10, fig.height=3.2}
strat_hist(goRes, pval="over_represented_pvalue", covariate="rand_covar", maxy=10)
```

## Multiple-Testing Correction

Generating the *SummarizedBenchmark* object:
 
```{r setup-benckmark, message=FALSE}
## rename columns and prepare for benchmarking
res <- dplyr::select(goRes, over_represented_pvalue, numInCat, rand_covar) %>%
    dplyr::rename(pval = over_represented_pvalue,
                  ind_covariate = numInCat) %>%
    dplyr::mutate(pval = pmin(pval, 1))

## generate default BenchDesign
bd <- initializeBenchDesign()
```

We don't include `ashq`, `fdrreg-e` and `fdrreg-t` from the analysis because
the necessary assumptions are not met in the current case study. Namely, effect sizes
and standard errors are not available for ASH, and the test statistics are not normally
distributed under the null and alternative, as required by Scott's FDR regression methods.

```{r run-benchmark}
if (!file.exists(bench_file)) {
    sGSEAMouse <- buildBench(bd, res, ftCols = "ind_covariate")
    saveRDS(sGSEAMouse, file = bench_file)
} else {
    sGSEAMouse <- readRDS(bench_file)
}
```

We'll also compare the results to an uninformative (random) covariate.

```{r run-benchmark-rand}
if (!file.exists(bench_file_uninf)) {
  res$ind_covariate <- res$rand_covar
  sGSEAMouse_rand <- buildBench(bd, res, ftCols = "ind_covariate")
  saveRDS(sGSEAMouse_rand, file = bench_file_uninf)
} else {
  sGSEAMouse_rand <- readRDS(bench_file_uninf)
}
```


## Benchmark Metrics

### Gene Set Size

```{r}
assayNames(sGSEAMouse) <- "qvalue"
sGSEAMouse <- addDefaultMetrics(sGSEAMouse)
```

```{r plottingResults}
rejections_scatter(sGSEAMouse, as_fraction = FALSE, supplementary = FALSE)
```
  
```{r}
plotFDRMethodsOverlap(sGSEAMouse, alpha = 0.1, supplementary = FALSE,
                      order.by = "freq", nsets = 100)
```

```{r}
covariateLinePlot(sGSEAMouse, alpha = 0.1, covname = "ind_covariate", trans="log1p")
```

### Random

```{r}
assayNames(sGSEAMouse_rand) <- "qvalue"
sGSEAMouse_rand <- addDefaultMetrics(sGSEAMouse_rand)
sGSEAMouse_rand <- estimatePerformanceMetrics(sGSEAMouse_rand, addColData=TRUE)
```

```{r plottingResults-rand}
rejections_scatter(sGSEAMouse_rand, as_fraction=FALSE, supplementary=FALSE)
```
  
```{r}
plotFDRMethodsOverlap(sGSEAMouse_rand, alpha=0.1, supplementary=FALSE, order.by="freq", nsets=100)
```

```{r}
covariateLinePlot(sGSEAMouse_rand, alpha = 0.1, covname = "ind_covariate", trans = "log1p")
```

## Covariate comparison

Here we compare the method ranks for the two covariates at alpha = 0.10.

```{r}
plotMethodRanks(c(bench_file, bench_file_uninf), 
                colLabels = c("Set Size", "Random"), 
                alpha = 0.10, xlab = "Covariate", 
                excludeMethods = NULL)
``` 

# Session Info

```{r}
sessionInfo()
```
