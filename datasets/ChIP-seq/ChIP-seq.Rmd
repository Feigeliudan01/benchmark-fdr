---
title: "Case Study: ChIP-seq Differential Peak Calling"
author: "Mingxiang Teng"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
   html_document:
        toc: true
        toc_float: true
        highlight: tango
        number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Summary

Common analyses in ChIP-seq data include the calling of peaks within individual
samples, and the testing of differential peaks across conditions. While peak
calling continues to be the most wide-spread method applied to ChIP-seq data,
differential testing has gained popularity with the increased availability of
data from large-scale experiments with more complex designs.

In differential peak calling, classical pipelines often begin by first calling peaks
in samples, followed by performing differential testing using existing algorithms
developed for other genomic data tpyes (e.g. RNA-seq). However, with these approaches,
testing is only performed on a filtered set of genomic regions, namely those with
significance in at least in one condition, resulting in only a limited number of
null tests cases.
 
To avoid this limitation, we examine ChIP-seq data of the histone H3K4Me3, an active
marker of gene expression, and focus our analysis on promoter regions of all genes
for this histone marker. By doing so, we avoid limiting the set of tests to only
regions significant in at least one sample, while also keeping most regions of
interest for this histone marker.

Here, we focus on test differential peaks between two cell lines (K562 and Gm12878)
using publicly available data generated by the ENCODE Project. These two cell lines
comprise the largest sequencing datasets in the ENCODE Project. As mentioned above,
we use ChIP-seq data for histone H3K4Me3 in our analysis. Differential peaks are tested
using DESeq2.

We note that while the algorithm for differential testing, DESeq2, used here is the same
as that used in our analysis of RNA-seq data, benchmarking on ChIP-seq still provides
insights for a unique data structure which has been widely utilized in modern genomics.

# Workspace Setup

```{r, wkspace-setup, results='hide', message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(magrittr)
library(SummarizedBenchmark)
library(BiocParallel)
library(GenomicRanges)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(DESeq2)
library(Rsubread)

## load helper functions
for (f in list.files("../R", "\\.(r|R)$", full.names = TRUE)) {
    source(f)
}

## project data/results folders
datdir <- "data"
resdir <- "results"
dir.create(datdir, showWarnings = FALSE)
dir.create(residr, showWarnings = FALSE)

## set up parallel backend
cores <- as.numeric(Sys.getenv("SLURM_NTASKS"))
multicoreParam <- MulticoreParam(workers = cores)
```

# Data Preparation

We downloaded the bam files directly from UCSC ENCODE portal.

```{r, encode-download}
broad_url <- "http://hgdownload.soe.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeBroadHistone/"
broad_bams <- c("wgEncodeBroadHistoneGm12878H3k4me3StdAlnRep1.bam",
                "wgEncodeBroadHistoneGm12878H3k04me3StdAlnRep2V2.bam",
                "wgEncodeBroadHistoneK562H3k4me3StdAlnRep1.bam",
                "wgEncodeBroadHistoneK562H3k4me3StdAlnRep2.bam")

for (i_bam in broad_bams) {
    if (!file.exists(file.path(datdir, i_bam))) {
        download.file(paste0(broad_url, i_bam),
                      destfile = file.path(datdir, i_bam))
    }
    i_bai <- paste0(i_bam, ".bai")
    if (!file.exists(file.path(datdir, i_bai))) {
        download.file(paste0(broad_url, i_bai),
                      destfile = file.path(datdir, i_bai))
    }
}

uw_url <- "http://hgdownload.soe.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeUwHistone/"
uw_bams <- c("wgEncodeUwHistoneGm12878H3k4me3StdAlnRep1.bam",
             "wgEncodeUwHistoneGm12878H3k4me3StdAlnRep2.bam",
             "wgEncodeUwHistoneK562H3k4me3StdAlnRep1.bam",
             "wgEncodeUwHistoneK562H3k4me3StdAlnRep2.bam")

for (i_bam in uw_bams) {
    if (!file.exists(file.path(datdir, i_bam))) {
        download.file(paste0(uw_url, i_bam),
                      destfile = file.path(datdir, i_bam))
    }
    i_bai <- paste0(i_bam, ".bai")
    if (!file.exists(file.path(datdir, i_bai))) {
        download.file(paste0(uw_url, i_bai),
                      destfile = file.path(datdir, i_bai))
    }
}
```

We determine sample metadata from the file names.

```{r}
bamfiles <- list.files(datdir, pattern = 'bam$', full = TRUE)
labs <- gsub("wgEncode(.*)Histone.*", "\\1", basename(bamfiles))
cells <- gsub("wgEncode.*Histone(.*)H3k.*", "\\1", basename(bamfiles))

meta <- data.frame(cellline = cells, lab = labs, file = bamfiles)
```

Next, we identify promotor regions using the UCSC "Known Gene" annotations for
human genome assembly hg19 (GRCh37). 

```{r}
prom <- promoters(genes(TxDb.Hsapiens.UCSC.hg19.knownGene))
seqlevels(prom, force = TRUE) <- seqlevels(prom)[!grepl("_", seqlevels(prom))]
```

# Data Analysis

## Differential Testing

We count sequencing reads for all promoter regions here, and test for differential peaks using these counts.

```{r count, results='hide', message=FALSE, warning=FALSE}
deseq_res  <- file.path(resdir, "h3k4me3.rda")
if (file.exists(deseq_res)) {
    load(deseq_res)
} else {
    ## count reads in each promotor region
    anno <- data.frame(GeneID = seq_len(length(prom)),
                       Chr = seqnames(prom),
                       Start = start(prom),
                       End = end(prom),
                       Strand = strand(prom))
    rc <- featureCounts(files = bamfiles,
                        annot.ext = anno,
                        allowMultiOverlap = TRUE,
                        minOverlap = 50,
                        readExtension3 = 150,
                        ignoreDup = TRUE)$counts

    ## perform differential testing
    dds <- DESeqDataSetFromMatrix(countData = rc,
                                  colData = as.data.frame(meta),
                                  design= ~ lab + cellline)
    dds <- DESeq(dds, fitType = "mean")
    dat <- as.data.frame(results(dds))
    colnames(dat) <- c('ind_covariate', 'effect_size', 'SE',
                       'stat', 'pval', 'padj')
    
    ## compute test-statistic from p-value for ASH
    dat <- dplyr::mutate(dat,
                         test_statistic = qnorm(exp(log(pval)-log(2)),
                                                lower.tail=FALSE),
                         test_statistic = test_statistic * sign(effect_size))

    save(deseq, dat, file = deseq_res)
}

## remove regions with effect sizes = NA
dat <- dat[!is.na(dat[, 2]), ]
```

## Covariate Diagnostics

Here, we can see that the covariant variable is actually informative.

### Mean Coverage

We consider the average coverage across conditions and replicates as a
potential covariate of interest. This is motivated by our prior assumption that
ChIP-seq data always involves two sets of regions: signal and background.
Sometimes, there are a few regions with signal coverage between signal and background.
In this example, we see that p-values are differently distributed under low, 
median and high coverage. 

```{r, chipseq-diag, fig.width=10, fig.height=3.5}
strat_hist(dat, pvalue = "pval", covariate = "ind_covariate", maxy = 2)
rank_scatter(dat, pvalue = "pval", covariate = "ind_covariate")
```

## Multiple-Testing Correction

We use the common `BenchDesign` with the set of multiple testing correction
methods already included.

```{r, chipseq-benchdesign}
bd <- initializeBenchDesign()
```

Now, we're ready to construct the `SummarizedBenchmark` object, which will run
the functions specified in each method.

```{r, chipseq-sb, results="hide", message=FALSE}
resN <- paste0(resdir, "/chipseq_summarizedBenchmark_", nrow(dat), ".RData")
if (!file.exists(resN)) {
    sb <- buildBench(bd, data = dat, ftCols = c("ind_covariate"),
                     parallel = TRUE, BPPARAM = multicoreParam)
    save(sb, file = resN)
} else {
    load(resN)
}
```

## Benchmark Metrics

Next, we'll add the default performance metric for q-value assays. First, we have
to rename the assay to 'qvalue'.

```{r, chipseq-metrics}
assayNames(sb) <- "qvalue"
sb <- addDefaultMetrics(sb)
```

Now, we'll plot the results.

```{r, chipseq-plot, results="hide", width=15, height=15}
# plot nrejects by method overall and stratified by covariate
rejections_scatter(sb, supplementary = FALSE)

rejection_scatter_bins(sb, covariate = "ind_covariate",
                       bins = 4, supplementary = FALSE)

plotFDRMethodsOverlap(sb,  alpha = 0.05, nsets = ncol(sb),
                      order.by = "freq", decreasing = TRUE,
                      supplementary = FALSE)

# properties of method-exclusive discoveries
methods <- c("ashs", "lfdr", "ihw-a10", "bl-df03", "qvalue", "bh", "bonf")
plotCovariateBoxplots(sb, alpha = 0.1, nsets = 6,
                      methods = methods, trans = log2, maxNum = 5)
```

# Session Info

```{r}
sessionInfo()
```
