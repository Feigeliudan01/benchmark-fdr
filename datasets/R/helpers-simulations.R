#' Simulate Collection of Test Statistics
#'
#' Function for simulating a large set of (independent) test results.
#' Test statistics and p-values are directly simulated from a specified
#' test-statistic distribution (`tstat`) and perturbed according to a specified
#' noise distribution (`tstat_dist`). This simulator resembles the simulations carried
#' out in the manuscripts of the Boca-Leek, ASH, and IHW methods.
#' (For IHW, in particular, the simulations illustrating the "size investing strategy"
#' fall under this class of simulations.)
#'
#' @param X simulation index
#' @param bench BenchDesign object of methods to run on simulated data set.
#' @param m number of test statistics.
#' @param pi0 proportion of null hypotheses. Can either be a single numeric value
#'        between 0 and 1 or a function which takes a numeric vector (i.e. 'informative
#'        covariate' values) and returns a vector of the same length containing null
#'        probabilities between 0 and 1. 
#' @param icovariate specification for the independent covariate, must be a function
#'        which takes an integer value and returns a vector of the specified length to
#'        be used as the independent covariate.
#' @param tstat expected test statistic under the alternative, can either be a single
#'        numeric value or a function which takes an integer as input and returns a
#'        numeric vector of test statistics of the specified length.
#' @param tstat_dist sampling distribution of test statistic, must be a function
#'        which takes a vector of test statistics, and returns a list of perturbed
#'        test statistics of the same length.
#' @param null_dist distribution under the null used to calculate p-values from the
#'        test statistic, must be a function which takes the full vector of null and
#'        alternative test statistics and return the corresponding p-values.
#' @param execute logical whether benchmarking should be executed or if the simulated
#'        data set should be returned. (default = TRUE)
#' @param seed integer seed for random number generator, ignored if NULL. (default = NULL) 
#'
#' @return
#' SummarizedBenchmark generated by calling `buildBench` with the specified
#' BenchDesign object and a simulated data set. If `execute = FALSE`, the simulated
#' data set is returned.
#' 
#' @details
#' If a function is specified for either of `effect_size` or `icovariate`, a function must also be
#' specified for the other parameter.
#' Within the function, the specified BenchDesign object is run against a simulated
#' data.frame with the following  columns.
#' * `qvalue`: 0/1 indicator whether data simulated under null (0) or alternative (1)
#' * `effect_size`: simulated effect size - effect size + sampling noise
#' * `test_statistic`: same as `effect_size` (NOT scaled by SE estimate)
#' * `pval`: test p-value calculated from test-statistic using `null_dist`
#' * `ind_covariate`: the independent covariate
#' * `SE`: true standard deviations for sampling distributions (for ASH)
#' 
#' @md
#' @author Patrick Kimes
simIteration <- function(X, bench, m, pi0, tstat, tstat_dist, null_dist,
                         icovariate, execute = TRUE, seed = NULL) {
    if (!is.null(seed)) { set.seed(seed * X) }
    stopifnot(is.function(tstat))
    stopifnot(is.function(tstat_dist))
    stopifnot(is.function(icovariate))
    
    ## simulate indep covariate from icovariate function
    ind_cov <- icovariate(m)
    stopifnot(length(ind_cov) == m)

    ## pi0 returns probability of null, sample alts from [1 - pi0s]
    if (is.function(pi0)) {
        pi0s <- pi0(ind_cov)
    } else if (length(pi0) == 1) {
        pi0s <- rep(pi0, m)
    } else {
        stop("pi0 must be function or single numeric value")
    }
    stopifnot(length(pi0s) == m)
    stopifnot(min(pi0s) >= 0 && max(pi0s) <= 1)
    alts <- which(rbinom(m, 1, 1 - pi0s) == 1)
    
    ## generate set of null (0) and alternative test statistics
    ts <- rep(0, m)
    if (length(alts) > 0) {
        ts[alts] <- tstat(length(alts))
    }
    
    ## determine (true) SD of sampling dist used to perturb each stat
    SE <- tstat_dist(ts, se = TRUE)

    ## perturb each stat
    ts <- tstat_dist(ts)
    stopifnot(length(ts) == m)
    
    ## null/alt indicator
    H <- rep(0, m)
    H[alts] <- 1

    ## calculate p-values 
    pv <- null_dist(ts)

    ## 'effect size' is same as test statistic
    es <- ts

    ## organize in data.frame
    dat <- data.frame(qvalue = H, effect_size = es, test_statistic = ts, 
                      pval = pv, ind_covariate = ind_cov, SE = SE)

    ## return data if not executing
    if (!execute) {
        return(as_tibble(dat))
    }

    buildBench(bench, dat, truthCol = "qvalue", ptabular = TRUE,
               ftCols = c("ind_covariate", "effect_size"))
}



## ##############################################################################
## informative covariates
## - if x ~ U(0,1), then expect 80%, 90%, 95% pi0 for all cases
## ##############################################################################

## step function (4 steps)
pi0_step <- function(pi0) {
    stopifnot(pi0 < 1, pi0 >= 0.5)
    function(x) {
        pi0 - (1-pi0)/2 +
            (1-pi0)/4 * (x > 0.25) +
            (1-pi0)/2 * (x > 0.5) +
            (1-pi0)/4 * (x > 0.75)
    }
}

## shifted/stretched cubic function
pi0_cubic <- function(pi0) {
    stopifnot(pi0 < 1, pi0 >= 2/3)
    function(x) { (1-x)^(1/3) * 4*(1-pi0) + 4 * pi0 - 3 }
}

## shifted/stretched cosine function (non-monotone)
pi0_cosine <- function(pi0) {
    stopifnot(pi0 < 1, pi0 >= 1/2)
    function(x) { (1-pi0) * cos(2*pi*x) + pi0 }
}

pi0_sine <- function(pi0) {
    stopifnot(pi0 < 1, pi0 >= 1/2)
    function(x) { (1-pi0) * sin(2*pi*x) + pi0 }
}


## ##############################################################################
## CODE DERIVED FROM EXTERNAL SOURCE
## source: https://github.com/stephenslab/ash/blob/94a3347/code/dsc-shrink/datamakers/datamaker.R
## source: https://github.com/stephenslab/ash/blob/d06047e/code/dsc-shrink/add_named_scenarios.R
## license: not listed
## date: 2017/10/18
## modified: Patrick Kimes
## ##############################################################################

## test statistic distributions used in ASH simulations
params <- list(spiky = list(c(.4, .2, .2, .2), c(0, 0, 0, 0), c(.25, .5, 1, 2)),
               skew = list(c(1/4, 1/4, 1/3, 1/6), c(-2, -1, 0, 1), c(2, 1.5, 1, 1)),
               bignormal = list(c(1), c(0), c(4)),
               bimodal = list(c(0.5, 0.5), c(-2, 2), c(1, 1)),
               flat_top = list(rep(1/7, 7), c(-1.5, -1, -0.5, 0, 0.5, 1, 1.5), rep(0.5, 7)),
               near_normal = list(c(2/3, 1/3), c(0, 0), c(1, 2)))

## function factory to generate mixture normal samplers 
rnormmix_generator <- function(g) {
    k <- unique(sapply(g, length))
    stopifnot(length(k) == 1)
    stopifnot(sum(g[[1]]) == 1)
    function(n) {
        comp <- sample(1:k, n, g[[1]], replace=TRUE)
        rnorm(n, g[[2]][comp], g[[3]][comp])
    }
}

## ASH effect-size distributions
sampler_spiky <- rnormmix_generator(params$spiky)
sampler_skew <- rnormmix_generator(params$skew)
sampler_bignormal <- rnormmix_generator(params$bignormal)
sampler_bimodal <- rnormmix_generator(params$bimodal)
sampler_flat_top <- rnormmix_generator(params$flat_top)
sampler_near_normal <- rnormmix_generator(params$near_normal)

## ##############################################################################
## END CODE DERIVED FROM EXTERNAL SOURCE
## ##############################################################################

## function factory: normal distribution
rnorm_generator <- function(m, s = 1) {
    function(n) {
        rnorm(n, m, s)
    }
}

## function factory: non-central t distribution
rt_generator <- function(df, m = 0) {
    if (m == 0) {
        return(function(n) { rt(n, df) })
    } else if (df > 1) {
        ncp <- m / gamma((df-1)/2) * gamma(df/2) / sqrt(df/2)
        return(function(n) { rt(n, df, ncp) })
    } else {
        stop("eep! my author didn't write me to accept ",
             "(df <= 1) & (m != 0). sorry!")
    }
}

## function factory: non-central chi-sq distribution
rchisq_generator <- function(df, ncp = 0) {
    return(function(n) { rchisq(n, df, ncp) })
}





## ##############################################################################
## ##############################################################################

## function factory: normal perturbation
## - returns functions which takes input vector and simulates normal
##   random variables with specified vector as means.
## - returned function can also return (true) SD of sampling dist

#' normal distribution samplers
rnorm_perturber <- function(s = 1) {
    function(m, se = FALSE) {
        if (se) { return(rep(s, length(m))) }
        rnorm(length(m), m, s)
    }
}

#' non-central t-distribution samplers
rt_perturber <- function(df) {
    if (df <= 2) {
        stop("var not defined for non-central t with df <= 2.")
    }
    function(m, se = FALSE) {
        ncp <- m / gamma((df-1)/2) * gamma(df/2) / sqrt(df/2)
        if (se) { return(sqrt(df*(1+ncp^2) / (df-2) - m^2)) }
        ## rt(..) w/ length(ncp) > 1 throws warning - just call underlying code
        rnorm(length(m), ncp) / sqrt(rchisq(length(m), df) / df)
    }
}

#' non-central chi-square distirbution samplers
rchisq_perturber <- function(df) {
    function(ncp, se = FALSE) {
        stopifnot(ncp >= 0)
        if (se) { return(sqrt(2 * df + 4 * ncp)) }
        rchisq(length(ncp), df, ncp)
    }
}


## ##############################################################################
## ##############################################################################

## function factory: two-sided normal p-value calculator
## @param s standard deviation of null zero-centered normal distribution
rnorm_2pvaluer <- function(s) {
    function(x) { 2 * (1 - pnorm(abs(x), 0, s)) }
}


## function factory: two-sided t p-value calculator
## @param df degrees of freedom of null zero-centered t-distribution
rt_2pvaluer <- function(df) {
    function(x) { 2 * (1 - pt(abs(x), df)) }
}


## function factory: chi-sq p-value calculator
## @param df degrees of freedom of null zero-centered t-distribution
rchisq_pvaluer <- function(df) {
    function(x) { 1 - pchisq(x, df) }
}

