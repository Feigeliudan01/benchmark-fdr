---
title: "Yeast RNA-seq 48 sample simulation study"
author: "Keegan Korthauer"
output: 
    html_document:
        toc: true
        toc_float: true
        highlight: tango
        number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

This is an analysis of the yeast data with 48 biological replicates in each of 
two conditions (analyzed in this [publication](https://www.ncbi.nlm.nih.gov/pubmed/26206307/)). 
We chose this experiment because of the large number of biological replicates, which
will allow us to (1) implement null comparisons on random subsets of samples within
one condition, (2) compare FDR approaches on their ability to discover 'true positive' 
DE genes using subsets of the full dataset, where 'true positive' is defined as a 
gene detected as DE using all 48 samples in each condition, and (3) start with a null
comparison and add in artificial differences to a subset of genes to define
'true positives'. 

Processed count table is made available by the authors in their paper codebase 
[GitHub repository](https://github.com/bartongroup/profDGE48). 

In this Rmd we will carry out simulations for multiple
replicates, and plot results averaging over the replications.

# Set up workspace

```{r, results='hide', message=FALSE}
# Load packages and source benchmark FDR
library(SummarizedBenchmark)
library(data.table)
library(tidyr)
library(dplyr)
library(readr)
library(ggplot2)
library(magrittr)
library(cowplot)
library(purrr)
library(DESeq2)
library(tibble)
library(ggthemes)
library(R.utils)

## load helper functions
for (f in list.files("../R", "\\.(r|R)$", full.names = TRUE)) {
    source(f)
}

# set up data / results directories
datdir <- "yeast-data"
resdir <- "../../results/RNAseq"
dir.create(datdir, showWarnings = FALSE)
dir.create(resdir, showWarnings = FALSE)

# results files that will be generated
resfile_n5 <- file.path(resdir, "yeast-results-null5.rds")
resfile_n10 <- file.path(resdir, "yeast-results-null10.rds")
resfile_d5 <- file.path(resdir, "yeast-results-de5.rds")
resfile_d10 <- file.path(resdir, "yeast-results-de10.rds")

# set up parallel backend
library(BiocParallel)
nCores <- 20
register(MulticoreParam(workers = nCores))
```

# Data download

First, we download the processed count data from GitHub. There is one file for the 
Snf2 condition and one file for the wild type condition. The Snf2 condition is a yeast
strain that has the transcriptional regulator gene Snf2 knocked out. Each of these
files is a compressed `tar.gz` archive that contains a 
single bam file for each replicate in each condition, which we'll place in a subdirectory
called `r datdir`.

```{r, download}
download.file(url = "https://github.com/bartongroup/profDGE48/raw/master/Preprocessed_data/Snf2_countdata.tar.gz",
              destfile = file.path(datdir, "Snf2_countdata.tar.gz"))
download.file(url = "https://github.com/bartongroup/profDGE48/raw/master/Preprocessed_data/WT_countdata.tar.gz", 
              destfile = file.path(datdir, "WT_countdata.tar.gz"))

gunzip(file.path(datdir, "Snf2_countdata.tar.gz")) 
gunzip(file.path(datdir, "WT_countdata.tar.gz")) 

untar(file.path(datdir, "Snf2_countdata.tar"), exdir = datdir) 
untar(file.path(datdir, "WT_countdata.tar"), exdir = datdir) 

file.remove(file.path(datdir, "Snf2_countdata.tar"), 
            file.path(datdir, "WT_countdata.tar"))
```

Each of the data files contains two columns, one with a gene/feature name, and one
with the count value.

## Read data into R and create a count table

Here we make use of the map and map2 functions in the `purrr` package, to swiftly 
apply the `read_tsv` function from `readr` to read in all of the 96 sample tables, 
as well as add in the sample name (derived from the file name) to each subtable.
Finally, the `reduce` function is used to join all the replicates together.

```{r, readin, results='hide', message=FALSE}
files <- dir(path = datdir, pattern = "*.bam.gbgout", full.names = TRUE)
sample_names <- sapply(strsplit(dir(path = datdir, pattern = "*.bam.gbgout"), "_MID"),
                       function(x) x[[1]])

counts <- files %>%
  purrr::map(read_tsv, col_names = FALSE) %>% # read in all the files individually
  purrr::map2(sample_names, ~ dplyr:::rename(.x, !! .y := X2, feature = X1) ) %>% # add sample names
  purrr::reduce(left_join, by = "feature") # reduce with rbind into one dataframe
```

# Analysis of full 48v48 (non-null)

Here we'll carry out an analysis of the full dataset, comparing the controls to the
knockout samples. The fold changes observed in this comparison will be used when 
generating the non-null simulated data in the following sections.

We're ready to construct a DESeq2 object. First we pull out the feature names and
add them as rownames for the count table, and next we construct a column data object
that houses the sample names, replicate numbers, and condition factor (WT versus
Snf2 knockout). 

## Set up DESeq2 object 

```{r, deseq}
feats <- (counts %>% select(1))$feature
counts <- as.matrix(counts %>% select(-1))
rownames(counts) <- feats

coldat <- tibble(sample=colnames(counts)) %>% 
  separate(sample, sep="_", into=c("condition", "replicate"), remove=FALSE) %>%
  mutate(condition = factor(condition))

# filter low count genes
counts <- counts[rowMeans(counts) > 1,]

dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = coldat,
                              design= ~ condition)

# results on full set
dds <- DESeq(dds)
resultsNames(dds) # lists the coefficients
resFULL <- results(dds, name="condition_WT_vs_Snf2", independentFiltering = F)

head(resFULL)

sum(resFULL$padj < 0.05, na.rm=T)
```

## Check assumptions

There are several thousand genes detected using the full set. Next, we'll build input data frame for summarized benchmark.

```{r}
geneExp <- tbl_df(data.frame(geneName=rownames(resFULL), 
                             pval=resFULL$pvalue, 
                             SE=resFULL$lfcSE,
                             ind_covariate = resFULL$baseMean, 
                             effect_size=resFULL$log2FoldChange, 
                             test_statistic=resFULL$stat,
                             pzero=rowSums(counts(dds)==0)/ncol(counts(dds))))

# filter NAs and those with less than 50% expressed 
geneExp <- geneExp %>% na.omit() %>% dplyr::filter(pzero < 0.5)
```

We'll create a plot to examine the distribution of effect sizes, since
the ash method assumes that the distribution of true (unobserved) effect
sizes is unimodal.

```{r}
ggplot(data=geneExp, aes(effect_size)) +
  geom_histogram(bins=30)
```

We'll also explore how the standard error (used by ash) 
correlates with the independent covariate (used by methods that incorporate 
covariates), in order to get an idea of how these pieces of information relate
to one another.

```{r}
ggplot(data=geneExp, aes(x = ind_covariate, y = SE)) +
  geom_hex(bins = 100) +
  scale_x_continuous(trans="log10") +
  xlab("Covariate: Mean gene expression") 
```


Look at covariate diagnostic plots.

```{r, width=15, height=15}
strat_hist(geneExp, pvalue="pval", covariate="ind_covariate", maxy=32)
```

```{r}
rank_scatter(geneExp, pvalue="pval", covariate="ind_covariate")
```

## FDR benchmarking

Run benchmark methods. 

```{r}
bd <- initializeBenchDesign()
sb <- bd %>% buildBench(data=geneExp, parallel = FALSE)

assayNames(sb) <- "qvalue"
sb <- addDefaultMetrics(sb)
```

Plot results.

```{r}
rejections_scatter(sb, supplementary=FALSE)
```

```{r}
plotFDRMethodsOverlap(sb, alpha=0.05, nsets=ncol(sb), order.by="freq", decreasing=TRUE, supplementary=FALSE)

```

# Simulation set up

Next, we'll analyze random splits of one condition, both with and without the 
addition of simulated DE genes. Here we'll create a function that we can use to 
run one replicate given sample size and number of DE gene settings. This will be
looped over many replications and results averaged over them.

```{r}
#' @param X simnumber
#' @param seed random seed
#' @param dds is the full DESeq2 dataset
#' @param resFULL is the results object from running DESeq2 on dds (used in
#'   to obtain the fold change effect sizes when adding non-null genes)
#' @param sampleSize is the number of samples in each condition
#' @param nDE is the number of DE genes
#' @param bd is the bench design object
#' @param BPPARAM is the BiocParallel bpparam argument to pass to DESeq. Since
#'  parallelization happens by forking multiple instances of this function, we 
#'  will specify only one worker per DEseq intance.
simulateOneSplit <- function(X, rseed, dds, resFULL, nDE, sampleSize,
                             bd){
  
  # set random seed
  set.seed(as.numeric(X)*as.numeric(rseed))
  
  # select a random subset of 20 WT samples
  dds_test <- dds[,colData(dds)$condition == "Snf2"]
  dds_test <- dds_test[,sample(1:ncol(dds_test), sampleSize*2)]

  # add a fake condition column to coldat
  colData(dds_test)$fake <-  factor(c(rep("A", sampleSize), 
                                      rep("B", sampleSize))[sample(1:(sampleSize*2), 
                                                                   sampleSize*2)])
  design(dds_test) <- ~fake
  truth <- rep(FALSE, nrow(dds_test))
  
  if(nDE > 0){
    # pick random set of nDE genes to add signal to
    DE <- sample(1:nrow(dds_test), nDE)
    truth <- rep(FALSE, nrow(dds_test))
    truth[DE] <- TRUE
    names(truth) <- rownames(dds_test)
 
    # randomly sample a log2FC from original FCs (without regard to DE)
    log2FC <- rep(0, nrow(dds_test))
    log2FC[DE] <- resFULL$log2FoldChange[DE]

    counts_new <- counts(dds_test)
    counts_new[,colData(dds_test)$fake=="A"] <- counts(dds_test)[,colData(dds_test)$fake=="A"] * 2^log2FC
    counts_new <- apply(counts_new, 2, as.integer)
    counts(dds_test) <- counts_new
  }
  
  dds_test <- DESeq(dds_test, parallel = FALSE)
  resultsNames(dds_test) # lists the coefficients
  resTEST <- results(dds_test, name="fake_B_vs_A", independentFiltering = FALSE)

 
  geneExp <- tbl_df(data.frame(geneName=rownames(resTEST), 
                               pval=resTEST$pvalue, 
                               SE=resTEST$lfcSE, 
                               ind_covariate = resTEST$baseMean,
                               effect_size = resTEST$log2FoldChange, 
                               test_statistic = resTEST$stat,
                               qvalue = truth,
                               pzero = rowSums(counts(dds_test)==0)/
                                       ncol(counts(dds_test))  ))
  
  # filter NAs and those with less than 50% expressed 
  geneExp <- geneExp %>% na.omit() %>% dplyr::filter(pzero < 0.5)

  sb <- bd %>% buildBench(data=geneExp, parallel = FALSE, 
                          truthCols = "qvalue",
                          ftCols = "ind_covariate")
  
  assayNames(sb) <- "qvalue"
sb <- addDefaultMetrics(sb)
  pf <- estimatePerformanceMetrics(sb, tidy=TRUE, alpha=seq(0.01, 0.1, 0.01))
pf %>% filter(performanceMetric %in% c("rejections", "FDR", "TPR")) %>%
  with(table(is.na(value), blabel, performanceMetric))


  rowData(sb)$log2FC <- geneExp$effect_size
  
  return(sb)
}
 
```



We'll also set some parameters that will be common to all simulations. These
include the number of replications, the bench design object, the set of 
methods to exclude in the results plots, and the alpha cutoff level to 
be used when plotting the aggregated Upset results.

```{r}
B <- 100
bd <- initializeBenchDesign() # only needs to be done once
excludeSet <- c("unadjusted", "bl-df02", "bl-df04", "bl-df05")
ualpha <- 0.05
```

We also add in Scott's FDR Regression (both
`nulltype = "empirical"` and `nulltype = "theoretical"`)
since our test statistics are approximately t-distributed. 

```{r}
bd <- addBMethod(bd, "scott-theoretical",
                     FDRreg::FDRreg,
                     function(x) { x$FDR },
                     z = test_statistic,
                     features = model.matrix( ~  splines::bs(ind_covariate, df = 3) - 1),
                     nulltype = 'theoretical',
                     control = list(lambda = 0.01))
bd <- addBMethod(bd, "scott-empirical",
                     FDRreg::FDRreg,
                     function(x) { x$FDR },
                     z = test_statistic,
                     features = model.matrix( ~  splines::bs(ind_covariate, df = 3) - 1),
                     nulltype = 'empirical',
                     control = list(lambda = 0.01))
```


Here's a helper function to return the number of methods with rejections at
a particular alpha level (this helps us determine whether or not to plot the
aggregated upset plot - if there aren't at least 2 methods it will throw an
error, which is a problem for the null simulations).

```{r}
#' @param res standardized metric data.table generated using
#'        standardize_results.
#' @param alpha alpha cutoff
#' @param filterSet which methods to exclude from consideration 
numberMethodsReject <- function(res, alphacutoff, filterSet){
  res <- res %>% 
    filter(is.na(param.alpha) | (param.alpha == alphacutoff)) %>%
    filter(!(blabel %in% filterSet)) %>%
    filter(alpha == alphacutoff) %>%
    filter(performanceMetric == "rejections") %>%
    select(blabel, performanceMetric, value) %>%
    group_by(blabel) %>%
    summarize(mean_value = mean(value)) %>%
    filter(mean_value > 0)
  return(nrow(res))
}

```


# Sim N5: Null Comparison 5v5

Here we'll repeat the above, but for a null comparison 5 versus 5 Snf2 samples,
where the groups are selected randomly. This will be done for 100 random splits.

## Generate a list of SB results objects

```{r n5, results='hide', message=FALSE}
rseed <- 225
sampleSize <- 5
nDE <- 0

if (!file.exists(resfile_n5)){
  null5 <- bplapply(X=1:B, FUN=simulateOneSplit, rseed=rseed, dds=dds, 
                   resFULL=resFULL, nDE=nDE, sampleSize=sampleSize, bd=bd)
  saveRDS(null5, file = resfile_n5)
}else{
  null5 <- readRDS(file = resfile_n5)
}

# Check for missing results (if any methods threw an error for relevant metrics).
rowSums(sapply(null5, function(x) colSums(is.na(assays(x)$qvalue)) > 0))
```

## Plot average results over replications

Plot results. 

```{r}
res5 <- plotsim_standardize(null5, alpha = seq(0.01, 0.10, 0.01))

plotsim_average(res5, met="rejections",filter_set = excludeSet,
                merge_ihw = TRUE, errorBars=TRUE) 
plotsim_average(res5, met="TNR",filter_set = excludeSet,
                merge_ihw = TRUE, errorBars=TRUE) 

covariateLinePlot(null5, alpha=0.05, covname="log2FC", nbins=25, 
                 trans="log1p")
covariateLinePlot(null5, alpha=0.05, covname="ind_covariate", nbins=25, 
                 trans="log1p")

if (numberMethodsReject(res5, alphacutoff=ualpha, filterSet=excludeSet) >= 3){
  aggupset(null5, alpha=ualpha, supplementary = FALSE, return_list = FALSE) 
}else{
  message("Not enough methods found rejections at alpha ", ualpha, 
          "; skipping upset plot")
}

```

# Sim N10: Null Comparison 10v10

Here we'll repeat the above, but for a null comparison 10 versus 10 Snf2 samples,
where the groups are selected randomly. This will be done for 100 random splits.

## Generate a list of SB results objects

```{r n10, results='hide', message=FALSE}
rseed <- 837
sampleSize <- 10
nDE <- 0

if (!file.exists(resfile_n10)){
  null10 <- bplapply(X=1:B, FUN=simulateOneSplit, rseed=rseed, dds=dds, 
                   resFULL=resFULL, nDE=nDE, sampleSize=sampleSize, bd=bd)
  saveRDS(null10, file = resfile_n10)
}else{
  null10 <- readRDS(file = resfile_n10)
}

# Check for missing results (if any methods threw an error for relevant metrics).
rowSums(sapply(null10, function(x) colSums(is.na(assays(x)$qvalue)) > 0))
```

## Plot average results over replications

Plot results.

```{r}
res10 <- plotsim_standardize(null10, alpha = seq(0.01, 0.10, 0.01))

plotsim_average(res10, met="rejections",filter_set = excludeSet,
                merge_ihw = TRUE, errorBars=TRUE) 
plotsim_average(res10, met="TNR",filter_set = excludeSet,
                merge_ihw = TRUE, errorBars=TRUE) 

covariateLinePlot(null10, alpha=0.05, covname="log2FC", nbins=25, 
                 trans="log1p")
covariateLinePlot(null10, alpha=0.05, covname="ind_covariate", nbins=25, 
                 trans="log1p")

if (numberMethodsReject(res10, alphacutoff=ualpha, filterSet=excludeSet) >= 3){
  aggupset(null10, alpha=ualpha, supplementary = FALSE, return_list = FALSE) 
}else{
  message("Not enough methods found rejections at alpha ", ualpha, 
          "; skipping upset plot")
}

```



# Sim D5: DE Comparison 5v5

Here we'll repeat the above, but for a DE comparison 5 versus 5 Snf2 samples,
where the groups are selected randomly and 500 DE genes are added. 
This will be done for 100 random splits.

## Generate a list of SB results objects

```{r d5, results='hide', message=FALSE}
rseed <- 198
sampleSize <- 5
nDE <- 500

if (!file.exists(resfile_d5)){
  de5 <- bplapply(X=1:B, FUN=simulateOneSplit, rseed=rseed, dds=dds, 
                   resFULL=resFULL, nDE=nDE, sampleSize=sampleSize, bd=bd)
  saveRDS(de5, file = resfile_d5)
}else{
  de5 <- readRDS(file = resfile_d5)
}

# Check for missing results (if any methods threw an error for relevant metrics).
rowSums(sapply(de5, function(x) colSums(is.na(assays(x)$qvalue)) > 0))
```

## Plot average results over replications

Plot results. 

```{r}
res5d <- plotsim_standardize(de5, alpha = seq(0.01, 0.10, 0.01))

plotsim_average(res5d, met="rejections",filter_set = excludeSet,
                merge_ihw = TRUE, errorBars=TRUE) 
plotsim_average(res5d, met="FDR",filter_set = excludeSet,
                merge_ihw = TRUE, errorBars=TRUE) 
plotsim_average(res5d, met="TPR",filter_set = excludeSet,
                merge_ihw = TRUE, errorBars=TRUE) 

covariateLinePlot(de5, alpha=0.05, covname="log2FC", nbins=25, 
                 trans="log1p")
covariateLinePlot(de5, alpha=0.05, covname="ind_covariate", nbins=25, 
                 trans="log1p")

if (numberMethodsReject(res5d, alphacutoff=ualpha, filterSet=excludeSet) >= 3){
  aggupset(de5, alpha=ualpha, supplementary = FALSE, return_list = FALSE) 
  
}else{
  message("Not enough methods found rejections at alpha ", ualpha, 
          "; skipping upset plot")
}

```

# Sim D10: DE Comparison 10v10

Here we'll repeat the above, but for a DE comparison 10 versus 10 Snf2 samples,
where the groups are selected randomly and 500 DE genes are added.
This will be done for 100 random splits.

## Generate a list of SB results objects

```{r d10, results='hide', message=FALSE}
rseed <- 961
sampleSize <- 10
nDE <- 500

if(!file.exists(resfile_d10)){
  de10 <- bplapply(X=1:B, FUN=simulateOneSplit, rseed=rseed, dds=dds, 
                   resFULL=resFULL, nDE=nDE, sampleSize=sampleSize, bd=bd)
  saveRDS(de10, file = resfile_d10)
}else{
  de10 <- readRDS(file = resfile_d10)
}

# Check for missing results (if any methods threw an error for relevant metrics).
rowSums(sapply(de10, function(x) colSums(is.na(assays(x)$qvalue)) > 0))
```

## Plot average results over replications

Plot results.

```{r}
res10d <- plotsim_standardize(de10, alpha = seq(0.01, 0.10, 0.01))

plotsim_average(res10d, met="rejections",filter_set = excludeSet,
                merge_ihw = TRUE, errorBars=TRUE) 
plotsim_average(res10d, met="FDR",filter_set = excludeSet,
                merge_ihw = TRUE, errorBars=TRUE) 
plotsim_average(res10d, met="TPR",filter_set = excludeSet,
                merge_ihw = TRUE, errorBars=TRUE) 

covariateLinePlot(de10, alpha=0.05, covname="log2FC", nbins=25, 
                 trans="log1p")
covariateLinePlot(de10, alpha=0.05, covname="ind_covariate", nbins=25, 
                 trans="log1p")

if (numberMethodsReject(res10d, alphacutoff=ualpha, filterSet=excludeSet) >= 3){
  aggupset(de10, alpha=ualpha, supplementary = FALSE, return_list = FALSE) 
}else{
  message("Not enough methods found rejections at alpha ", ualpha, 
          "; skipping upset plot")
}

```

# Session information

```{r}
sessionInfo()
```
