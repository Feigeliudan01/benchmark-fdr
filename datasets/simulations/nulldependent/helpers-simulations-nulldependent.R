#' Simulate Collection of Test Statistics
#'
#' Function for simulating a large set of (independent) test results.
#' For Normal and t-distributed test statistics, effect sizes are directly simulated
#' from a specified true effect size distribution (`es_dist`) and perturbed according to a
#' specified noise distribution with correspond standard errors to obtain the observed set of
#' test statistics (`ts_dist`). For Chi-squared distributed test statistics, the notions of
#' effect size and standard error are not well defined, and we therefore just set the standard
#' error to 1 and effect size equal to the test statistic. This does not matter for our simulations,
#' where the effect size and standard error are only used by a single method (ASH) which is
#' not included in the comparisons under the Chi-squared distribution. This simulator resembles
#' the simulations carried out in the manuscripts of the Boca-Leek, ASH, and IHW methods.
#' (For IHW, in particular, the simulations illustrating the "size investing strategy" fall under
#' this class of simulations.)
#'
#' @param X simulation index
#' @param bench BenchDesign object of methods to run on simulated data set.
#' @param m number of test statistics.
#' @param pi0 proportion of null hypotheses. Can either be a single numeric value
#'        between 0 and 1 or a function which takes a numeric vector (i.e. 'informative
#'        covariate' values) and returns a vector of the same length containing null
#'        probabilities between 0 and 1. 
#' @param icovariate specification for the independent covariate, must be a function
#'        which takes an integer value and returns a vector of the specified length to
#'        be used as the independent covariate.
#' @param es_dist expected effect size under the alternative, can either be a single
#'        numeric value or a function which takes an integer as input and returns a
#'        numeric vector of effect sizes of the specified length.
#' @param ts_dist sampling distribution of effect size, must be a function taking two
#'        inputs, a vector of true effect sizes and a logical value whether to return
#'        the perturbed effect sizes or the corresponding standard error. The perturbed
#'        effect sizes and standard errors are used to compute the test statistics.
#' @param null_dist distribution under the null used to calculate p-values from the
#'        test statistic, must be a function which takes the full vector of null and
#'        alternative test statistics and return the corresponding p-values.
#' @param null_dependence the proportion of null tests to be dependent on the covariate.
#'        When 0, all null tests are independent of the coviarate. For the subset of
#'        null tests with a dependence on the covariate, the p-values are sampled from a
#'        truncated normal distributions with means equal to the covariate values and
#'        standard deviation 0.1. (default = 0.4)
#' @param execute logical whether benchmarking should be executed or if the simulated
#'        data set should be returned. (default = TRUE)
#' @param seed integer seed for random number generator, ignored if NULL. (default = NULL) 
#'
#' @return
#' SummarizedBenchmark generated by calling `buildBench` with the specified
#' BenchDesign object and a simulated data set. If `execute = FALSE`, the simulated
#' data set is returned.
#' 
#' @details
#' If a function is specified for either of `effect_size` or `icovariate`, a function must also be
#' specified for the other parameter.
#' Within the function, the specified BenchDesign object is run against a simulated
#' data.frame with the following  columns.
#' * `qvalue`: 0/1 indicator whether data simulated under null (0) or alternative (1)
#' * `effect_size`: simulated effect size - true effect size + sampling noise
#' * `test_statistic`: `effect_size` divided by `SE`
#' * `pval`: test p-value calculated from test-statistic using `null_dist`
#' * `ind_covariate`: the independent covariate
#' * `SE`: standard errors for the `test_statistic`
#' 
#' @md
#' @author Patrick Kimes
simNullDependent <- function(X, bench, m, pi0, es_dist, ts_dist, null_dist,
                             null_inv, icovariate, null_dependence = 0.4,
                             execute = TRUE, seed = NULL) {

    library(truncnorm)

    if (!is.null(seed)) { set.seed(seed * X) }
    stopifnot(is.function(es_dist))
    stopifnot(is.function(ts_dist))
    stopifnot(is.function(icovariate))
    
    ## simulate indep covariate from icovariate function
    ind_cov <- icovariate(m)
    stopifnot(length(ind_cov) == m)

    ## pi0 returns probability of null, sample alts from [1 - pi0s]
    if (is.function(pi0)) {
        pi0s <- pi0(ind_cov)
    } else if (length(pi0) == 1) {
        pi0s <- rep(pi0, m)
    } else {
        stop("pi0 must be function or single numeric value")
    }
    stopifnot(length(pi0s) == m)
    stopifnot(min(pi0s) >= 0 && max(pi0s) <= 1)

    h01 <- rbinom(m, 1, 1 - pi0s)
    alts <- which(h01 == 1)
    nulls <- which(h01 != 1)
    
    ## generate set of null (0) and alternative true effect sizes
    es <- rep(0, m)
    if (length(alts) > 0) {
        es[alts] <- es_dist(length(alts))
    }
    
    ## determine SE of test statistics
    SE <- ts_dist(es, se = TRUE)

    ## perturb effect sizes to get observed effect sizes
    ## simulate dependence between test statistics and ind cov under null
    esp_nulls <- runif(length(nulls))
    nulls_sub <- rbinom(length(nulls), 1, null_dependence) == 1L
    if (sum(nulls_sub) > 0) {
        esp_nulls[nulls_sub] <- rtruncnorm(sum(nulls_sub), 0, 1, ind_cov[nulls][nulls_sub], .1)
    }
    es[nulls] <- null_inv(esp_nulls)

    ## randomly perturb alternative tests
    es[alts] <- es[alts] + rnorm(length(alts), 0, 1)
    
    stopifnot(length(es) == m)

    ## create alternative effect size set with no null dependence
    es_indep <- es
    es_indep[nulls] <- sample(es_indep[nulls])
    
    ## null/alt indicator
    H <- rep(0, m)
    H[alts] <- 1

    ## test stat for normal and t-dist is just (effect size) / SE 
    ts <- es / SE
    ts_indep <- es_indep / SE
    
    ## calculate p-values 
    pv <- null_dist(ts)
    pv_indep <- null_dist(ts_indep)
    
    ## organize in data.frame
    dat <- data.frame(qvalue = H, effect_size = es,
                      test_statistic = ts, pval = pv,
                      ind_covariate = ind_cov, SE = SE)

    ## organize in data.frame - without
    dat_indep <- data.frame(qvalue = H, effect_size = es_indep,
                            test_statistic = ts_indep, pval = pv_indep,
                            ind_covariate = ind_cov, SE = SE)
    
    ## return data if not executing
    if (!execute) {
        return(as_tibble(dat))
    }

    ## run methods w/ null dependence
    res_d <- buildBench(bench, dat, truthCol = "qvalue", ptabular = TRUE,
                        ftCols = c("ind_covariate", "effect_size"))

    ## run methods w/ null independene
    res_i <- buildBench(bench, dat_indep, truthCol = "qvalue", ptabular = TRUE,
                        ftCols = c("ind_covariate", "effect_size"))
    
    list(null_dependent = res_d, null_independent = res_i)
}
