---
title: "Testing out AdaPT"
author: "Rafalab Journal Club Members"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
---

```{r}
library("tidyverse")
```

The AdaPT method was proposed in Lei and Fithian (2016) with accompanying code (`AdaPT.R`). While based on the paper, the method appears to be relevant to the present benchmark study, because the paper does not include substantial empirical studies (no simulations, one data application), it is unclear whether [1] the method performs reasonably well in practice, and [2] the corresponding implementation is sufficient for data practicioners.

Here, we first consider a simple simulation setting to develop an understanding of the output of the method, since documentation is sparse. We use the `du_tsim` function to simulate a simple t-test based dataset with the rank of the sample variance used as the informative covariate.

```{r}
source("../R/du_tsim.R")
```

We use the AdaPT implementation fron the author's GitHub repo.

```{r}
library(RCurl)
script <- getURL("https://raw.githubusercontent.com/lihualei71/AdaPT/master/AdaPT.R")
eval(parse(text = script))
```

We simulate the simple data set and apply AdaPT.

```{r}

sim_df <- du_tsim(m = 2e4, pi0 = .9, effect_size = 2,
                  n_sample = 10, n_group = 2, icovariate = TRUE)
res <- AdaPT(x = rank(sim_df$ind_covariate),
             pvals = sim_df$pval,
             quiet = TRUE)

```

The returned object is a list with `r length(res)` entries.

```{r}
lapply(res, class)
lapply(res, function(x) if (is.matrix(x)) dim(x) else length(x))
```

Entries are either vectors of the same length or matrices with the same number of columns, and number of rows equal to the number of tested hypotheses. Presumably, the columns of each matrix element correspond to the entries of each vector element in the output.

First, we can take a quick look at the vector elements. 

```{r}
vec_tib <- tibble(step = res$step,
                  fdp = res$fdp,
                  num_rej = res$num_rej)
```

The `step` vector is likely the iteration index for the updates used in the AdaPT algorithm. We can plot the two other vectors, `fdp` and `num_rej` as a function of `step`.

```{r, fig.width = }
vec_tib %>%
    gather(var, value, -step) %>%
    ggplot(aes(x = step, y = value, label = step)) +
    geom_line(alpha = 1/2) + geom_point() +
    geom_text(vjust = 1/2, hjust = -0.5) + 
    facet_grid(var ~ ., scales = "free_y") +
    theme_bw()
```

Both the false discovery proportion and number of rejects follow a strictly decreasing relationship with the step index. Only a subset of steps are included in the final output.

For each of the matrix elements in the output, we only examine the first column since this corresponds to the largest (and presumably final) entry in the `res$step` vector.

```{r}
mat_tib <- tibble(s = res$s[, 1],
                  pi = res$pi[, 1],
                  mu = res$mu[, 1])
```

We can also merge this table with the original `sim_df` data.frame of p-values.

```{r}
mat_tib <- mat_tib %>%
    bind_cols(sim_df)
```

Based on the notation used in Section 4 of Lei and Fithian (2016), `s` is the significance thresholds for the p-values calculated as a function of the informative covariate, here `rank(ind_covariate)`. The other two variables, `pi` and `mu` are the parameters of the two-group Gamma GLM mixture model (fit to the negative log p-values) used to determine the AdaPT threshold, `s`.

We can start by plotting the `s` as a function of the informative covariate and faceted by the truth (`H = 0` or `H = 1`).

```{r, fig.width = 7, fig.height = 4}
mat_tib %>%
    ggplot(aes(x = rank(ind_covariate), y = s)) +
    geom_point(alpha = 1/20) + 
    theme_bw() + facet_grid(factor(H) ~ .)
```

That's a very interesting looking curve, and the trend follows what we expect. We can also check if our understanding of `s` is correct by thresholding the p-values against the `s` cutoff and comparing against the `num_rej` values of the output.

```{r}
all(colSums(sim_df$pval < res$s) == res$num_rej)
```

Wonderful!


