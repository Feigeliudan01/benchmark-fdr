---
title: "Simulation Study: Null Settings"
author: "Patrick Kimes"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
   html_document:
        toc: true
        toc_float: true
        highlight: tango
        number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Summary

In this set of simulations, we only consider settings where all tests are null.

# Workspace Setup

```{r, wkspace-setup, results='hide', message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(SummarizedBenchmark)
library(parallel)

## load helper functions
for (f in list.files("../R", "\\.(r|R)$", full.names = TRUE)) {
    source(f)
}

## project data/results folders
resdir <- "results"
dir.create(resdir, showWarnings = FALSE, recursive = TRUE)

## intermediary files we create below
gauss_file <- file.path(resdir, "null-benchmark-gaussian.rds")
tdist_file <- file.path(resdir, "null-benchmark-t5.rds")
chisq_file <- file.path(resdir, "null-benchmark-chisq4.rds")

## number of cores for parallelization
cores <- 20
B <- 100

## define bechmarking design
bd <- initializeBenchDesign()
```

We include Scott's FDR Regression in the analysis. We include both `nulltype = "empirical"` and
`nulltype = "theoretical"`. In both cases, test statistics are modeled as being
sampled from mean-shifted normal distributions with equal variance under the null and alternative.
While `nulltype = "theoretical"` makes the additional assumption that the null is standard normal,
`nulltype = "empirical"` attempts to estimate the mean and variance under the null empirically.
While the assumptions of `nulltype = "theoretical"` are met for a subset of the simulations, we
include `nulltype = "empirical"` as this is not true for all simulations, and not necessarily
reflective of all real data sets.

```{r}
bdplus <- bd
bdplus <- addBMethod(bdplus, "scott-theoretical",
                     FDRreg::FDRreg,
                     function(x) { x$FDR },
                     z = test_statistic,
                     features = model.matrix( ~  splines::bs(ind_covariate, df = 3) - 1),
                     nulltype = 'theoretical',
                     control = list(lambda = 0.01))
bdplus <- addBMethod(bdplus, "scott-empirical",
                     FDRreg::FDRreg,
                     function(x) { x$FDR },
                     z = test_statistic,
                     features = model.matrix( ~  splines::bs(ind_covariate, df = 3) - 1),
                     nulltype = 'empirical',
                     control = list(lambda = 0.01))
```

All simulation settings will share the following parameters.

```{r parameters-shared}
m <- 20000                        # integer: number of hypothesis tests
pi0 <- 1                          # numeric: proportion of null hypotheses
tstat <- function(x) { 0 }        # functional: dist of alternative test stats
icovariate <- runif               # functional: independent covariate
```

Simulation results will be presented excluding a subset of methods, and
for certain plots (upset plots), a single alpha cutoff will be used.

```{r}
excludeSet <- c("unadjusted", "bl-df02", "bl-df04", "bl-df05")
ualpha <- 0.05
```

# Gaussian Setting

First, we consider the null setting with gaussian noise.

## Data Simulation

```{r gauss-parameters}
tstat_dist <- rnorm_perturber(1)  # functional: sampling dist/noise for test stats
null_dist <- rnorm_2pvaluer(1)    # functional: dist to calc p-values
seed <- 608
```

We next run the simulations (including Scott's FDR Regression).

```{r gauss-run-simulation}
if (file.exists(gauss_file)) {
    res <- readRDS(gauss_file)
} else {
    res <- mclapply(X = 1:B, FUN = simIteration, bench = bdplus, m = m,
                    pi0 = pi0, tstat = tstat, icovariate = icovariate,
                    tstat_dist = tstat_dist, null_dist = null_dist,
                    seed = seed, mc.cores = cores)
    saveRDS(res, file = gauss_file)
}
```

## Covariate Diagnostics

Here, we show the relationship between the independent covariate and p-values for a
single replication of the experiment.

```{r gauss-one-simulation}
onerun <- simIteration(bdplus, m = m, pi0 = pi0, tstat = tstat, tstat_dist = tstat_dist,
                       icovariate = icovariate, null_dist = null_dist, execute = FALSE)
```

```{r, gauss-diag-scatter, results = "hide", fig.width=4.5, fig.height=3.5}
rank_scatter(onerun, pvalue = "pval", covariate = "ind_covariate")
```

```{r, gauss-diag-hist, results = "hide", fig.width=10, fig.height=3.2}
strat_hist(onerun, pvalue = "pval", covariate = "ind_covariate", maxy = 5, numQ = 3)
```

## Benchmark Metrics

We plot the average results across `r B` simulations.

```{r gauss-metrics-averages, results = "hide"}
resdf <- plotsim_standardize(res, alpha = seq(0.01, 0.10, 0.01))

plotsim_average(resdf, met="rejections", filter_set = excludeSet,
                merge_ihw = TRUE, errorBars = TRUE) 

plotsim_average(resdf, met="FDR", filter_set = excludeSet,
                merge_ihw = TRUE, errorBars = TRUE) 
```

We also take a look at the distribution of rejects for each method as a function of
the effect size and independent covariate.

```{r gauss-metrics-covlineplot, results = "hide"}
covariateLinePlot(res, alpha = 0.05, covname = "effect_size", trans = "log1p")

covariateLinePlot(res, alpha = 0.05, covname = "ind_covariate", trans = "log1p")
```

Finally, (if enough methods produce rejections at `r ualpha`) we take a look at
the overlap of rejections between methods.

```{r gauss-metrics-upset, results = "hide"}
if (numberMethodsReject(resdf, alphacutoff = ualpha, filterSet = excludeSet) >= 3) {
    aggupset(res, alpha = ualpha, supplementary = FALSE, return_list = FALSE)
} else {
    message("Not enough methods found rejections at alpha ", ualpha, 
            "; skipping upset plot")
}
```

# Student's t Setting

Next, we consider the null setting with t-distributed noise.

## Data Simulation

```{r t5-parameters}
tstat_dist <- rt_perturber(5)  # functional: sampling dist/noise for test stats
null_dist <- rt_2pvaluer(5)    # functional: dist to calc p-values
seed <- 815
```

We next run the simulations (including Scott's FDR Regression).

```{r t5-run-simulation}
if (file.exists(tdist_file)) {
    res <- readRDS(tdist_file)
} else {
    res <- mclapply(X = 1:B, FUN = simIteration, bench = bdplus, m = m,
                    pi0 = pi0, tstat = tstat, icovariate = icovariate,
                    tstat_dist = tstat_dist, null_dist = null_dist,
                    seed = seed, mc.cores = cores)
    saveRDS(res, file = tdist_file)
}
```

## Covariate Diagnostics

Here, we show the relationship between the independent covariate and p-values for a
single replication of the experiment.

```{r t5-one-simulation}
onerun <- simIteration(bdplus, m = m, pi0 = pi0, tstat = tstat, tstat_dist = tstat_dist,
                       icovariate = icovariate, null_dist = null_dist, execute = FALSE)
```

```{r, t5-diag-scatter, results = "hide", fig.width=4.5, fig.height=3.5}
rank_scatter(onerun, pvalue = "pval", covariate = "ind_covariate")
```

```{r, t5-diag-hist, results = "hide", fig.width=10, fig.height=3.2}
strat_hist(onerun, pvalue = "pval", covariate = "ind_covariate", maxy = 5, numQ = 3)
```

## Benchmark Metrics

We plot the average results across `r B` simulations.

```{r t5-metrics-averages, results = "hide"}
resdf <- plotsim_standardize(res, alpha = seq(0.01, 0.10, 0.01))

plotsim_average(resdf, met="rejections", filter_set = excludeSet,
                merge_ihw = TRUE, errorBars = TRUE) 

plotsim_average(resdf, met="FDR", filter_set = excludeSet,
                merge_ihw = TRUE, errorBars = TRUE) 
```

We also take a look at the distribution of rejects for each method as a function of
the effect size and independent covariate.

```{r t5-metrics-covlineplot, results = "hide"}
covariateLinePlot(res, alpha = 0.05, covname = "effect_size", trans = "log1p")

covariateLinePlot(res, alpha = 0.05, covname = "ind_covariate", trans = "log1p")
```

Finally, (if enough methods produce rejections at `r ualpha`) we take a look at
the overlap of rejections between methods.

```{r t5-metrics-upset, results = "hide"}
if (numberMethodsReject(resdf, alphacutoff = ualpha, filterSet = excludeSet) >= 3) {
    aggupset(res, alpha = ualpha, supplementary = FALSE, return_list = FALSE) 
} else {
    message("Not enough methods found rejections at alpha ", ualpha, 
            "; skipping upset plot")
}
```

# Chi-Squared Setting

Finally, we consider the null setting with chi-squared distributed noise.

## Data Simulation

```{r chisq4-parameters}
tstat_dist <- rchisq_perturber(4)  # functional: sampling dist/noise for test stats
null_dist <- rchisq_pvaluer(4)     # functional: dist to calc p-values
seed <- 1023
```

We next run the simulations. We do not include FDR Regression because the test statistics
are not approximately normally distributed.

```{r chisq4-run-simulation}
if (file.exists(chisq_file)) {
    res <- readRDS(chisq_file)
} else {
    res <- mclapply(X = 1:B, FUN = simIteration, bench = bd, m = m,
                    pi0 = pi0, tstat = tstat, icovariate = icovariate,
                    tstat_dist = tstat_dist, null_dist = null_dist,
                    seed = seed, mc.cores = cores)
    saveRDS(res, file = chisq_file)
}
```

## Covariate Diagnostics

Here, we show the relationship between the independent covariate and p-values for a
single replication of the experiment.

```{r chisq4-one-simulation}
onerun <- simIteration(bd, m = m, pi0 = pi0, tstat = tstat, tstat_dist = tstat_dist,
                       icovariate = icovariate, null_dist = null_dist, execute = FALSE)
```

```{r, chisq4-diag-scatter, results = "hide", fig.width=4.5, fig.height=3.5}
rank_scatter(onerun, pvalue = "pval", covariate = "ind_covariate")
```

```{r, chisq4-diag-hist, results = "hide", fig.width=10, fig.height=3.2}
strat_hist(onerun, pvalue = "pval", covariate = "ind_covariate", maxy = 5, numQ = 3)
```

## Benchmark Metrics

We plot the average results across `r B` simulations.

```{r chisq4-metrics-averages, results = "hide"}
resdf <- plotsim_standardize(res, alpha = seq(0.01, 0.10, 0.01))

plotsim_average(resdf, met="rejections", filter_set = excludeSet,
                merge_ihw = TRUE, errorBars = TRUE) 

plotsim_average(resdf, met="FDR", filter_set = excludeSet,
                merge_ihw = TRUE, errorBars = TRUE) 
```

We also take a look at the distribution of rejects for each method as a function of
the effect size and independent covariate.

```{r chisq4-metrics-covlineplot, results = "hide"}
covariateLinePlot(res, alpha = 0.05, covname = "effect_size", trans = "log1p")

covariateLinePlot(res, alpha = 0.05, covname = "ind_covariate", trans = "log1p")
```

Finally, (if enough methods produce rejections at `r ualpha`) we take a look at
the overlap of rejections between methods.

```{r chisq4-metrics-upset, results = "hide"}
if (numberMethodsReject(resdf, alphacutoff = ualpha, filterSet = excludeSet) >= 3) {
    aggupset(res, alpha = ualpha, supplementary = FALSE, return_list = FALSE) 
} else {
    message("Not enough methods found rejections at alpha ", ualpha, 
            "; skipping upset plot")
}
```

# Session Info

```{r}
sessionInfo()
```
